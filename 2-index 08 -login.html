<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>로그인모달 - with regular expression</title>
    <link rel="stylesheet" href="style.css" />
    <!-- bootstrap ---중에 CSS는 고정(정적)이므로 link에 -->
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/css/bootstrap.min.css"
      rel="stylesheet"
      integrity="sha384-sRIl4kxILFvY47J16cr9ZwB07vP4J8+LH7qKQnuqkuIAvNWLzeN8tE5YBujZqJLB"
      crossorigin="anonymous"
    />
  </head>
  <body>
    <div class="black-bg show-modal">
      <div class="white-bg">
        <h4>로그인하세요</h4>
        <!--form이다. from이아닌-->
        <form action="success.html">
          <div class="my-3">
            <input type="text" class="form-control" id="email" />
          </div>
          <div class="my-3">
            <input type="password" class="form-control" id="pw" />
          </div>
          <button type="submit" class="btn btn-primary" id="send">전송</button>
          <button type="button" class="btn btn-secondary" id="close">
            닫기
          </button>
        </form>
      </div>
    </div>
    <!-- 설명 -->
    <div class="summary">레귤러익스프레션으로 검토기능 만들어보자</div>

    <script>
      const emailInput = document.getElementById("email");
      const pwInput = document.getElementById("pw");
      const formSubmit = document.querySelector("form");

      //아이디이메일 input감지 시 console에 출력
      emailInput.addEventListener("input", () => {
        console.log("아이디 입력함!");
      });
      //폼에 전송제출 눌러도 기본동작인 폼 전송 막기
      formSubmit.addEventListener("submit", (e) => {
        e.preventDefault();

        //아이디 입력값이 비어있을 시 모달창뜸
        if (emailInput.value.trim() == "") {
          alert("아이디를 입력하세요!");
        }
        //비번 입력값이 비어있을 시,짧을 시 모달창뜸
        if (pwInput.value.trim() == "") {
          alert("비밀번호를 입력하랏");
        } else if (pwInput.value.trim().length < 6) {
          alert("비번 넘 짧다");
        } else if (/[A-Z]/.test(pwInput.value) == false) {
          alert("대문자를 1자라도 입력하세요");
        }
      });

      // '닫기' 버튼 누르면 모달창 닫기
      document.getElementById("close").addEventListener("click", () => {
        document.querySelector(".black-bg").classList.remove("show-modal");
        // document.querySelector(".black-bg").style.display = "none"; //이건 CSS 수정하는 것
      });

      //모든 브라우저는 이벤트 버블링이 일어남
      // (이벤트가 상위 html로 퍼지는 현상)
      //그래서 이벤트 리스너안에 이벤트함수를 넣어서 제약사항을 걸어둬야함
      //예를들어서 검은색 부분만 클릭하면 닫히게 하고싶은데
      //그 아래 흰색부분까지 하위에 있어서 그거 눌러도 닫히게 되는 거 임
      document.querySelector(".black-bg").addEventListener("click", (e) => {
        // if(지금클릭한것==검은배경){클래스에 show-modal빼라}
        if (e.target == document.querySelector(".black-bg")) {
          document.querySelector(".black-bg").classList.remove("show-modal");
        }
        console.log(e.target); //실제 클릭위치 알려줌 => e.target
        // console.log(e.currentTarget); //지금 이벤트리스너가 달린 곳 알려줌=>e.currentTarget (this는 화살표 함수 사용할 때 안쓰는 것이 좋음. 옛날함수 function(){}에서는 써도 무관하지만)
        // console.log(e.preventDefault()); //이벤트 기본동작을 막아줌=>e.preventDefault()
        // console.log(e.stopPropagation()); // 이벤트 버블링을 중단=>e.stopPropagation()
      });

      //  화살표 함수 () => {}를 이벤트 리스너로 사용할 때는
      // this 대신 e.currentTarget을 쓰는 것이 훨씬 안전하고 명확합니다.

      // 화살표 함수 () => {} 안에서: this는 이벤트가 발생한 요소를 가리키지 않고,
      // 바깥 스코프(문맥)의 this를 그대로 물려받습니다. 대부분의 경우 이는 전역 객체인 window가 되므로,
      // 우리가 원하는 대로 동작하지 않아 버그의 원인이 되기 쉽습니다.

      // e.currentTarget: 어떤 종류의 함수를 쓰든 상관없이,
      // 항상 이벤트 리스너가 부착된 요소를 정확히 가리킵니다.
      // 예측 가능하고 일관성이 있죠.
    </script>
  </body>
</html>
